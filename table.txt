create table public.user_interactions (
  id bigserial not null,
  user_id bigint not null,
  place_id bigint not null,
  action text not null,
  rating double precision null,
  timestamp timestamp with time zone not null default now(),
  constraint user_interactions_pkey primary key (id),
  constraint user_interactions_user_id_fkey foreign KEY (user_id) references user_profiles (user_id) on delete CASCADE,
  constraint user_interactions_action_check check ((action = 'rate'::text))
) TABLESPACE pg_default;

create unique INDEX IF not exists idx_user_place on public.user_interactions using btree (user_id, place_id) TABLESPACE pg_default;


create table public.user_profiles (
  user_id bigint not null,
  lat double precision not null,
  long double precision not null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint user_profiles_pkey primary key (user_id)
) TABLESPACE pg_default;

create trigger set_timestamp_user_profiles BEFORE
update on user_profiles for EACH row
execute FUNCTION trigger_set_timestamp ();


create table public.cbf_user_profiles (
  user_id bigint not null,
  cbf_profile jsonb null,
  constraint cbf_user_profiles_pkey primary key (user_id),
  constraint cbf_user_profiles_user_id_fkey foreign KEY (user_id) references user_profiles (user_id)
) TABLESPACE pg_default;
